#!/usr/bin/env bash
# MSP.bs: MSP-like mail server log parser in Bash
# Nathan P. <me@tchbnl.net>
# 0.1a (Postfix)
set -euo pipefail

# Version and mail server variant
# Right now MSP.bs supports Postfix and has a WIP version for Exim
MSP_VERSION='0.1a (Postfix)'

# Nice text formatting options
MSP_TEXT_BOLD='\e[1m'
MSP_TEXT_RED='\e[31m'
MSP_TEXT_GREEN='\e[32m'
MSP_TEXT_UNSET='\e[0m'

# Path to the ${MAIL_SERVER} log file
# TODO: Add support for rotated log files
MSP_LOG_FILE='/var/log/maillog'

# The RBLs we check against
MSP_RBL_LIST=("b.barracudacentral.org"
              "bl.spamcop.net"
              "dnsbl.sorbs.net"
              "spam.dnsbl.sorbs.net"
              "ips.backscatterer.org"
              "zen.spamhaus.org")

# Help message
# Email Steve to discuss current rates and senior discounts
show_help() {
    cat << YOUR_ADVERTISEMENT_HERE
$(echo -e "${MSP_TEXT_BOLD}")MSP.bs:$(echo -e "${MSP_TEXT_UNSET}") MSP-like mail server log parser in Bash

USAGE: msp.bs [OPTION]
    --auth              Show mail server stats
    --rbl               Check IPs against common RBLs
    --help -h           Show this message
    --version -v        Show version information
YOUR_ADVERTISEMENT_HERE
}

# --auth/mail server stats run
# TODO: Add check for log file/empty log file
# TODO: Add checks for individual sections (like if there are no authenticated
# senders or logged subjects for some reason)
run_check() {
    echo "Getting cool Postfix facts..."
    echo

    # Dead simple queue size check. Might expand this in the future to alert if
    # the queue size is too high.
    queue_size="$(postqueue -j 2>/dev/null | wc -l)"

    echo -e "ðŸ“¨ ${MSP_TEXT_BOLD}Queue Size:${MSP_TEXT_UNSET} ${queue_size}"

    echo "There's nothing else to show here. Have a llama: ðŸ¦™"
    echo

    # These are senders that have logged in to actual email accounts
    echo -e "ðŸ”‘ ${MSP_TEXT_BOLD}Authenticated Senders${MSP_TEXT_UNSET}"

    grep 'sasl_username=' "${MSP_LOG_FILE}" | awk -F 'sasl_username=' '{print $2}' \
        | awk '{print $1}' | sort | uniq -c | sort -nr | head -n 10
    echo

    # Directories where unauthenticated mail was sent... IF POSTFIX SUPPORTED
    # THIS. Somebody running a shared mail server should definitely be using
    # Exim. Postfix is much too simple, which is great, except for stuff like
    # detailed logging, which is needed for that use case. This is also where
    # I admit that I do not like Postfix.
    #echo -e "ðŸ“‚ ${MSP_TEXT_BOLD}Directories${MSP_TEXT_UNSET}"
    #echo

    # System users that have sent mail (like with PHP's mail function)
    echo -e "ðŸ§” ${MSP_TEXT_BOLD}User Senders${MSP_TEXT_UNSET}"

    # Get our senders from the log
    user_senders="$(grep 'uid=' "${MSP_LOG_FILE}" | awk -F 'uid=' '{print $2}' \
        | awk '{print $1}')"

    # And then we need to get the actual username for them and sort it etc.
    for user in ${user_senders}; do
        getent passwd "${user}" | awk -F ':' '{print $1}'
    done | sort | uniq -c | sort -rn | head -n 10
    echo

    # Postfix supports logging subjects as well, but it's not enabled in the
    # default configuration. I add a rough check for this.
    echo -e "ðŸ’Œ ${MSP_TEXT_BOLD}The Usual Subjectsâ„¢${MSP_TEXT_UNSET}"

    # We suppress errors because we're already checking if this grep passes or
    # not with the if statement
    if ! grep -Fsq '/^Subject:/' /etc/postfix/header_checks; then
        echo "Subject logging appears to be disabled in the Postfix configuration. Here's"
        echo "how to enable it: https://github.com/tchbnl/MSP.bs/LOGGING.md"
    else
        # THIS LOOKS CURSED BUT I SWEAR IT WORKS
        grep 'Subject:' "${MSP_LOG_FILE}" | awk -F 'header Subject: ' '{print $2}' \
            | awk -F ' from localhost\\[127.0.0.1\\]' '{print $1}' \
            | sort | uniq -c | sort -nr | head -n 10
    fi
}

# --rbl/RBL check
# TODO: Add support for IPv6 addresses. Oh God.
rbl_check() {
    echo "Running RBL checks..."

    # Get our list of public IPs
    server_ips="$(hostname -I | xargs -n 1 \
        | grep -Ev '^10.0.0|^127.0.0.1|^172.16.0|^192.168.0|^169.254.0|::')"

    # And loop through each one
    for ip in ${server_ips}; do
        # We need to reverse the IP order for checks to "work"
        # This is a quick and dirty solution and will need to be replaced when
        # I add IPv6 support. I'm not looking forward to that.
        reversed_ip="$(echo "${ip}" | awk -F '.' '{print $4 "." $3 "." $2 "." $1}')"

        echo
        echo -e "${MSP_TEXT_BOLD}${ip}${MSP_TEXT_UNSET}"

        # Now we loop through each RBL inside the IP loop
        for rbl in "${MSP_RBL_LIST[@]}"; do
            # These two RBLs are too short for only one tab :(
            if [[ "${rbl}" = 'bl.spamcop.net' || "${rbl}" = 'dnsbl.sorbs.net' ]]; then
                echo -ne "\t${rbl}\t\t"
            else
                echo -ne "\t${rbl}\t"
            fi

            # We dig our reversed IP against each RBL. This might not work for
            # all RBLs, but I haven't been able to fully test it.
            rbl_result="$(dig "${reversed_ip}"."${rbl}" +short)"

            # And now we return the block result depending on what the response
            # from dig was
            if [[ -n "${rbl_result}" ]]; then
                echo -e "${MSP_TEXT_BOLD}${MSP_TEXT_RED}LISTED${MSP_TEXT_UNSET}"
            else
                echo -e "${MSP_TEXT_BOLD}${MSP_TEXT_GREEN}GOOD${MSP_TEXT_UNSET}"
            fi
        done
    done
}

# Command options
while [[ "${#}" -gt 0 ]]; do
    case "${1}" in
        --auth)
            run_check
            exit
            ;;

        # MSP requires --all to check all RBLs. We don't, but I figured I
        # should/might as well add this.
        --rbl | '--rbl --all')
            rbl_check
            exit
            ;;

        --help | -h)
            show_help
            exit
            ;;

        --version | -v)
            echo -e "${MSP_TEXT_BOLD}MSP.bs${MSP_TEXT_UNSET} ${MSP_VERSION}"
            exit
            ;;

        -*)
            echo -e "Not sure what ${1} is supposed to mean..."
            echo
            show_help
            exit
            ;;

        *)
            break
            ;;
    esac
done

# I've opted to have the auth check run if no options are given. This is
# (probably) what most people are using this for. Like me.
run_check
